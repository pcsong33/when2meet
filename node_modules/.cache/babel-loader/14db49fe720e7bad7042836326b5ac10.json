{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/patricksong/cs279/when2meet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _classCallCheck = require(\"/Users/patricksong/cs279/when2meet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/Users/patricksong/cs279/when2meet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _assertThisInitialized = require(\"/Users/patricksong/cs279/when2meet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\n\nvar _inherits = require(\"/Users/patricksong/cs279/when2meet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/Users/patricksong/cs279/when2meet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.preventScroll = exports.GridCell = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _styledComponents = _interopRequireDefault(require(\"styled-components\"));\n\nvar _add_minutes = _interopRequireDefault(require(\"date-fns/add_minutes\"));\n\nvar _add_hours = _interopRequireDefault(require(\"date-fns/add_hours\"));\n\nvar _add_days = _interopRequireDefault(require(\"date-fns/add_days\"));\n\nvar _start_of_day = _interopRequireDefault(require(\"date-fns/start_of_day\"));\n\nvar _is_same_minute = _interopRequireDefault(require(\"date-fns/is_same_minute\"));\n\nvar _format = _interopRequireDefault(require(\"date-fns/format\"));\n\nvar _typography = require(\"./typography\");\n\nvar _colors = _interopRequireDefault(require(\"./colors\"));\n\nvar _selectionSchemes = _interopRequireDefault(require(\"./selection-schemes\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n} // Import only the methods we need from date-fns in order to keep build size small\n\n\nvar Wrapper = _styledComponents.default.div.withConfig({\n  displayName: \"ScheduleSelector__Wrapper\",\n  componentId: \"sc-1ke4ka2-0\"\n})([\"display:flex;align-items:center;width:100%;user-select:none;\"]);\n\nvar Grid = _styledComponents.default.div.withConfig({\n  displayName: \"ScheduleSelector__Grid\",\n  componentId: \"sc-1ke4ka2-1\"\n})([\"display:grid;grid-template-columns:auto repeat(\", \",1fr);grid-template-rows:auto repeat(\", \",1fr);column-gap:\", \";row-gap:\", \";width:100%;\"], function (props) {\n  return props.columns;\n}, function (props) {\n  return props.rows;\n}, function (props) {\n  return props.columnGap;\n}, function (props) {\n  return props.rowGap;\n});\n\nvar GridCell = _styledComponents.default.div.withConfig({\n  displayName: \"ScheduleSelector__GridCell\",\n  componentId: \"sc-1ke4ka2-2\"\n})([\"place-self:stretch;touch-action:none;\"]);\n\nexports.GridCell = GridCell;\n\nvar DateCell = _styledComponents.default.div.withConfig({\n  displayName: \"ScheduleSelector__DateCell\",\n  componentId: \"sc-1ke4ka2-3\"\n})([\"width:100%;height:25px;background-color:\", \";&:hover{background-color:\", \";}\"], function (props) {\n  return props.selected ? props.selectedColor : props.unselectedColor;\n}, function (props) {\n  return props.hoveredColor;\n});\n\nvar DateLabel = (0, _styledComponents.default)(_typography.Subtitle).withConfig({\n  displayName: \"ScheduleSelector__DateLabel\",\n  componentId: \"sc-1ke4ka2-4\"\n})([\"@media (max-width:699px){font-size:12px;}margin:0;margin-bottom:4px;\"]);\nvar TimeText = (0, _styledComponents.default)(_typography.Text).withConfig({\n  displayName: \"ScheduleSelector__TimeText\",\n  componentId: \"sc-1ke4ka2-5\"\n})([\"@media (max-width:699px){font-size:10px;}text-align:right;margin:0;margin-right:4px;\"]);\n\nvar preventScroll = function preventScroll(e) {\n  e.preventDefault();\n};\n\nexports.preventScroll = preventScroll;\n\nvar ScheduleSelector = /*#__PURE__*/function (_React$Component) {\n  _inherits(ScheduleSelector, _React$Component);\n\n  var _super = _createSuper(ScheduleSelector);\n\n  function ScheduleSelector(props) {\n    var _this;\n\n    _classCallCheck(this, ScheduleSelector);\n\n    _this = _super.call(this, props);\n    _this.cellToDate = new Map();\n    _this.gridRef = null;\n\n    _this.renderDateCellWrapper = function (time) {\n      var startHandler = function startHandler() {\n        _this.handleSelectionStartEvent(time);\n      };\n\n      var selected = Boolean(_this.state.selectionDraft.find(function (a) {\n        return (0, _is_same_minute.default)(a, time);\n      }));\n      return /*#__PURE__*/React.createElement(GridCell, {\n        className: \"rgdp__grid-cell\",\n        role: \"presentation\",\n        key: time.toISOString() // Mouse handlers\n        ,\n        onMouseDown: startHandler,\n        onMouseEnter: function onMouseEnter() {\n          _this.handleMouseEnterEvent(time);\n        },\n        onMouseUp: function onMouseUp() {\n          _this.handleMouseUpEvent(time);\n        } // Touch handlers\n        // Since touch events fire on the event where the touch-drag started, there's no point in passing\n        // in the time parameter, instead these handlers will do their job using the default Event\n        // parameters\n        ,\n        onTouchStart: startHandler,\n        onTouchMove: _this.handleTouchMoveEvent,\n        onTouchEnd: _this.handleTouchEndEvent\n      }, _this.renderDateCell(time, selected));\n    };\n\n    _this.renderDateCell = function (time, selected) {\n      var refSetter = function refSetter(dateCell) {\n        if (dateCell) {\n          _this.cellToDate.set(dateCell, time);\n        }\n      };\n\n      if (_this.props.renderDateCell) {\n        return _this.props.renderDateCell(time, selected, refSetter);\n      } else {\n        return /*#__PURE__*/React.createElement(DateCell, {\n          selected: selected,\n          ref: refSetter,\n          selectedColor: _this.props.selectedColor,\n          unselectedColor: _this.props.unselectedColor,\n          hoveredColor: _this.props.hoveredColor\n        });\n      }\n    };\n\n    _this.renderTimeLabel = function (time) {\n      if (_this.props.renderTimeLabel) {\n        return _this.props.renderTimeLabel(time);\n      } else {\n        return /*#__PURE__*/React.createElement(TimeText, null, (0, _format.default)(time, _this.props.timeFormat));\n      }\n    };\n\n    _this.renderDateLabel = function (date) {\n      if (_this.props.renderDateLabel) {\n        return _this.props.renderDateLabel(date);\n      } else {\n        return /*#__PURE__*/React.createElement(DateLabel, null, (0, _format.default)(date, _this.props.dateFormat));\n      }\n    };\n\n    _this.state = {\n      selectionDraft: _toConsumableArray(_this.props.selection),\n      // copy it over\n      selectionType: null,\n      selectionStart: null,\n      isTouchDragging: false,\n      dates: ScheduleSelector.computeDatesMatrix(props)\n    };\n    _this.selectionSchemeHandlers = {\n      linear: _selectionSchemes.default.linear,\n      square: _selectionSchemes.default.square\n    };\n    _this.endSelection = _this.endSelection.bind(_assertThisInitialized(_this));\n    _this.handleMouseUpEvent = _this.handleMouseUpEvent.bind(_assertThisInitialized(_this));\n    _this.handleMouseEnterEvent = _this.handleMouseEnterEvent.bind(_assertThisInitialized(_this));\n    _this.handleTouchMoveEvent = _this.handleTouchMoveEvent.bind(_assertThisInitialized(_this));\n    _this.handleTouchEndEvent = _this.handleTouchEndEvent.bind(_assertThisInitialized(_this));\n    _this.handleSelectionStartEvent = _this.handleSelectionStartEvent.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(ScheduleSelector, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      // We need to add the endSelection event listener to the document itself in order\n      // to catch the cases where the users ends their mouse-click somewhere besides\n      // the date cells (in which case none of the DateCell's onMouseUp handlers would fire)\n      //\n      // This isn't necessary for touch events since the `touchend` event fires on\n      // the element where the touch/drag started so it's always caught.\n      document.addEventListener('mouseup', this.endSelection); // Prevent page scrolling when user is dragging on the date cells\n\n      this.cellToDate.forEach(function (value, dateCell) {\n        if (dateCell && dateCell.addEventListener) {\n          // @ts-ignore\n          dateCell.addEventListener('touchmove', preventScroll, {\n            passive: false\n          });\n        }\n      });\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      document.removeEventListener('mouseup', this.endSelection);\n      this.cellToDate.forEach(function (value, dateCell) {\n        if (dateCell && dateCell.removeEventListener) {\n          // @ts-ignore\n          dateCell.removeEventListener('touchmove', preventScroll);\n        }\n      });\n    } // Performs a lookup into this.cellToDate to retrieve the Date that corresponds to\n    // the cell where this touch event is right now. Note that this method will only work\n    // if the event is a `touchmove` event since it's the only one that has a `touches` list.\n\n  }, {\n    key: \"getTimeFromTouchEvent\",\n    value: function getTimeFromTouchEvent(event) {\n      var touches = event.touches;\n      if (!touches || touches.length === 0) return null;\n      var _touches$ = touches[0],\n          clientX = _touches$.clientX,\n          clientY = _touches$.clientY;\n      var targetElement = document.elementFromPoint(clientX, clientY);\n\n      if (targetElement) {\n        var cellTime = this.cellToDate.get(targetElement);\n        return cellTime !== null && cellTime !== void 0 ? cellTime : null;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"endSelection\",\n    value: function endSelection() {\n      this.props.onChange(this.state.selectionDraft);\n      this.setState({\n        selectionType: null,\n        selectionStart: null\n      });\n    } // Given an ending Date, determines all the dates that should be selected in this draft\n\n  }, {\n    key: \"updateAvailabilityDraft\",\n    value: function updateAvailabilityDraft(selectionEnd, callback) {\n      var _this$state = this.state,\n          selectionType = _this$state.selectionType,\n          selectionStart = _this$state.selectionStart;\n      if (selectionType === null || selectionStart === null) return;\n      var newSelection = [];\n\n      if (selectionStart && selectionEnd && selectionType) {\n        newSelection = this.selectionSchemeHandlers[this.props.selectionScheme](selectionStart, selectionEnd, this.state.dates);\n      }\n\n      var nextDraft = _toConsumableArray(this.props.selection);\n\n      if (selectionType === 'add') {\n        nextDraft = Array.from(new Set([].concat(_toConsumableArray(nextDraft), _toConsumableArray(newSelection))));\n      } else if (selectionType === 'remove') {\n        nextDraft = nextDraft.filter(function (a) {\n          return !newSelection.find(function (b) {\n            return (0, _is_same_minute.default)(a, b);\n          });\n        });\n      }\n\n      this.setState({\n        selectionDraft: nextDraft\n      }, callback);\n    } // Isomorphic (mouse and touch) handler since starting a selection works the same way for both classes of user input\n\n  }, {\n    key: \"handleSelectionStartEvent\",\n    value: function handleSelectionStartEvent(startTime) {\n      // Check if the startTime cell is selected/unselected to determine if this drag-select should\n      // add values or remove values\n      var timeSelected = this.props.selection.find(function (a) {\n        return (0, _is_same_minute.default)(a, startTime);\n      });\n      this.setState({\n        selectionType: timeSelected ? 'remove' : 'add',\n        selectionStart: startTime\n      });\n    }\n  }, {\n    key: \"handleMouseEnterEvent\",\n    value: function handleMouseEnterEvent(time) {\n      // Need to update selection draft on mouseup as well in order to catch the cases\n      // where the user just clicks on a single cell (because no mouseenter events fire\n      // in this scenario)\n      this.updateAvailabilityDraft(time);\n    }\n  }, {\n    key: \"handleMouseUpEvent\",\n    value: function handleMouseUpEvent(time) {\n      this.updateAvailabilityDraft(time); // Don't call this.endSelection() here because the document mouseup handler will do it\n    }\n  }, {\n    key: \"handleTouchMoveEvent\",\n    value: function handleTouchMoveEvent(event) {\n      this.setState({\n        isTouchDragging: true\n      });\n      var cellTime = this.getTimeFromTouchEvent(event);\n\n      if (cellTime) {\n        this.updateAvailabilityDraft(cellTime);\n      }\n    }\n  }, {\n    key: \"handleTouchEndEvent\",\n    value: function handleTouchEndEvent() {\n      var _this2 = this;\n\n      if (!this.state.isTouchDragging) {\n        // Going down this branch means the user tapped but didn't drag -- which\n        // means the availability draft hasn't yet been updated (since\n        // handleTouchMoveEvent was never called) so we need to do it now\n        this.updateAvailabilityDraft(null, function () {\n          _this2.endSelection();\n        });\n      } else {\n        this.endSelection();\n      }\n\n      this.setState({\n        isTouchDragging: false\n      });\n    }\n  }, {\n    key: \"renderFullDateGrid\",\n    value: function renderFullDateGrid() {\n      var _this3 = this;\n\n      var flattenedDates = [];\n      var numDays = this.state.dates.length;\n      var numTimes = this.state.dates[0].length;\n\n      for (var j = 0; j < numTimes; j += 1) {\n        for (var i = 0; i < numDays; i += 1) {\n          flattenedDates.push(this.state.dates[i][j]);\n        }\n      }\n\n      var dateGridElements = flattenedDates.map(this.renderDateCellWrapper);\n\n      for (var _i = 0; _i < numTimes; _i += 1) {\n        var index = _i * numDays;\n        var time = this.state.dates[0][_i]; // Inject the time label at the start of every row\n\n        dateGridElements.splice(index + _i, 0, this.renderTimeLabel(time));\n      }\n\n      return [\n      /*#__PURE__*/\n      // Empty top left corner\n      React.createElement(\"div\", {\n        key: \"topleft\"\n      })].concat(_toConsumableArray(this.state.dates.map(function (dayOfTimes, index) {\n        return /*#__PURE__*/React.cloneElement(_this3.renderDateLabel(dayOfTimes[0]), {\n          key: \"date-\".concat(index)\n        });\n      })), _toConsumableArray(dateGridElements.map(function (element, index) {\n        return /*#__PURE__*/React.cloneElement(element, {\n          key: \"time-\".concat(index)\n        });\n      })));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this4 = this;\n\n      return /*#__PURE__*/React.createElement(Wrapper, null, /*#__PURE__*/React.createElement(Grid, {\n        columns: this.state.dates.length,\n        rows: this.state.dates[0].length,\n        columnGap: this.props.columnGap,\n        rowGap: this.props.rowGap,\n        ref: function ref(el) {\n          _this4.gridRef = el;\n        }\n      }, this.renderFullDateGrid()));\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: // documentMouseUpHandler: () => void = () => {}\n    // endSelection: () => void = () => {}\n    // handleTouchMoveEvent: (event: React.SyntheticTouchEvent<*>) => void\n    // handleTouchEndEvent: () => void\n    // handleMouseUpEvent: (date: Date) => void\n    // handleMouseEnterEvent: (date: Date) => void\n    // handleSelectionStartEvent: (date: Date) => void\n    function getDerivedStateFromProps(props, state) {\n      // As long as the user isn't in the process of selecting, allow prop changes to re-populate selection state\n      if (state.selectionStart == null) {\n        return {\n          selectionDraft: _toConsumableArray(props.selection),\n          dates: ScheduleSelector.computeDatesMatrix(props)\n        };\n      }\n\n      return null;\n    }\n  }, {\n    key: \"computeDatesMatrix\",\n    value: function computeDatesMatrix(props) {\n      var startTime = (0, _start_of_day.default)(props.startDate);\n      var dates = [];\n      var minutesInChunk = Math.floor(60 / props.hourlyChunks);\n\n      for (var d = 0; d < props.numDays; d += 1) {\n        var currentDay = [];\n\n        for (var h = props.minTime; h < props.maxTime; h += 1) {\n          for (var c = 0; c < props.hourlyChunks; c += 1) {\n            currentDay.push((0, _add_minutes.default)((0, _add_hours.default)((0, _add_days.default)(startTime, d), h), c * minutesInChunk));\n          }\n        }\n\n        dates.push(currentDay);\n      }\n\n      return dates;\n    }\n  }]);\n\n  return ScheduleSelector;\n}(React.Component);\n\nexports.default = ScheduleSelector;\nScheduleSelector.defaultProps = {\n  selection: [],\n  selectionScheme: 'square',\n  numDays: 7,\n  minTime: 9,\n  maxTime: 23,\n  hourlyChunks: 1,\n  startDate: new Date(),\n  timeFormat: 'ha',\n  dateFormat: 'M/D',\n  columnGap: '4px',\n  rowGap: '4px',\n  selectedColor: _colors.default.blue,\n  unselectedColor: _colors.default.paleBlue,\n  hoveredColor: _colors.default.lightBlue,\n  onChange: function onChange() {}\n};","map":{"version":3,"mappings":"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","names":["Wrapper","styled","div","withConfig","displayName","componentId","Grid","props","columns","rows","columnGap","rowGap","GridCell","DateCell","selected","selectedColor","unselectedColor","hoveredColor","DateLabel","Subtitle","TimeText","Text","preventScroll","e","preventDefault","ScheduleSelector","constructor","cellToDate","Map","gridRef","renderDateCellWrapper","time","startHandler","handleSelectionStartEvent","Boolean","state","selectionDraft","find","a","React","className","role","key","toISOString","onMouseDown","onMouseEnter","handleMouseEnterEvent","onMouseUp","handleMouseUpEvent","onTouchStart","onTouchMove","handleTouchMoveEvent","onTouchEnd","handleTouchEndEvent","renderDateCell","refSetter","dateCell","set","ref","renderTimeLabel","timeFormat","renderDateLabel","date","dateFormat","selection","selectionType","selectionStart","isTouchDragging","dates","computeDatesMatrix","selectionSchemeHandlers","linear","selectionSchemes","square","endSelection","bind","componentDidMount","document","addEventListener","forEach","value","passive","componentWillUnmount","removeEventListener","getTimeFromTouchEvent","event","touches","length","clientX","clientY","targetElement","elementFromPoint","cellTime","get","onChange","setState","updateAvailabilityDraft","selectionEnd","callback","newSelection","selectionScheme","nextDraft","Array","from","Set","filter","b","startTime","timeSelected","renderFullDateGrid","flattenedDates","numDays","numTimes","j","i","push","dateGridElements","map","index","splice","dayOfTimes","cloneElement","element","render","el","startDate","minutesInChunk","Math","floor","hourlyChunks","d","currentDay","h","minTime","maxTime","c","Component","defaultProps","Date","colors","blue","paleBlue","lightBlue"],"sources":["/Users/patricksong/cs279/when2meet/node_modules/react-schedule-selector/src/lib/ScheduleSelector.tsx"],"sourcesContent":["import * as React from 'react'\nimport styled from 'styled-components'\n\n// Import only the methods we need from date-fns in order to keep build size small\nimport addMinutes from 'date-fns/add_minutes'\nimport addHours from 'date-fns/add_hours'\nimport addDays from 'date-fns/add_days'\nimport startOfDay from 'date-fns/start_of_day'\nimport isSameMinute from 'date-fns/is_same_minute'\nimport formatDate from 'date-fns/format'\n\nimport { Text, Subtitle } from './typography'\nimport colors from './colors'\nimport selectionSchemes, { SelectionSchemeType, SelectionType } from './selection-schemes'\n\nconst Wrapper = styled.div`\n  display: flex;\n  align-items: center;\n  width: 100%;\n  user-select: none;\n`\n\nconst Grid = styled.div<{ columns: number; rows: number; columnGap: string; rowGap: string }>`\n  display: grid;\n  grid-template-columns: auto repeat(${props => props.columns}, 1fr);\n  grid-template-rows: auto repeat(${props => props.rows}, 1fr);\n  column-gap: ${props => props.columnGap};\n  row-gap: ${props => props.rowGap};\n  width: 100%;\n`\n\nexport const GridCell = styled.div`\n  place-self: stretch;\n  touch-action: none;\n`\n\nconst DateCell = styled.div<{\n  selected: boolean\n  selectedColor: string\n  unselectedColor: string\n  hoveredColor: string\n}>`\n  width: 100%;\n  height: 25px;\n  background-color: ${props => (props.selected ? props.selectedColor : props.unselectedColor)};\n\n  &:hover {\n    background-color: ${props => props.hoveredColor};\n  }\n`\n\nconst DateLabel = styled(Subtitle)`\n  @media (max-width: 699px) {\n    font-size: 12px;\n  }\n  margin: 0;\n  margin-bottom: 4px;\n`\n\nconst TimeText = styled(Text)`\n  @media (max-width: 699px) {\n    font-size: 10px;\n  }\n  text-align: right;\n  margin: 0;\n  margin-right: 4px;\n`\n\ntype PropsType = {\n  selection: Array<Date>\n  selectionScheme: SelectionSchemeType\n  onChange: (newSelection: Array<Date>) => void\n  startDate: Date\n  numDays: number\n  minTime: number\n  maxTime: number\n  hourlyChunks: number\n  dateFormat: string\n  timeFormat: string\n  columnGap: string\n  rowGap: string\n  unselectedColor: string\n  selectedColor: string\n  hoveredColor: string\n  renderDateCell?: (datetime: Date, selected: boolean, refSetter: (dateCellElement: HTMLElement) => void) => JSX.Element\n  renderTimeLabel?: (time: Date) => JSX.Element\n  renderDateLabel?: (date: Date) => JSX.Element\n}\n\ntype StateType = {\n  // In the case that a user is drag-selecting, we don't want to call this.props.onChange() until they have completed\n  // the drag-select. selectionDraft serves as a temporary copy during drag-selects.\n  selectionDraft: Array<Date>\n  selectionType: SelectionType | null\n  selectionStart: Date | null\n  isTouchDragging: boolean\n  dates: Array<Array<Date>>\n}\n\nexport const preventScroll = (e: TouchEvent) => {\n  e.preventDefault()\n}\n\nexport default class ScheduleSelector extends React.Component<PropsType, StateType> {\n  selectionSchemeHandlers: { [key: string]: (startDate: Date, endDate: Date, foo: Array<Array<Date>>) => Date[] }\n  cellToDate: Map<Element, Date> = new Map()\n  // documentMouseUpHandler: () => void = () => {}\n  // endSelection: () => void = () => {}\n  // handleTouchMoveEvent: (event: React.SyntheticTouchEvent<*>) => void\n  // handleTouchEndEvent: () => void\n  // handleMouseUpEvent: (date: Date) => void\n  // handleMouseEnterEvent: (date: Date) => void\n  // handleSelectionStartEvent: (date: Date) => void\n  gridRef: HTMLElement | null = null\n\n  static defaultProps: Partial<PropsType> = {\n    selection: [],\n    selectionScheme: 'square',\n    numDays: 7,\n    minTime: 9,\n    maxTime: 23,\n    hourlyChunks: 1,\n    startDate: new Date(),\n    timeFormat: 'ha',\n    dateFormat: 'M/D',\n    columnGap: '4px',\n    rowGap: '4px',\n    selectedColor: colors.blue,\n    unselectedColor: colors.paleBlue,\n    hoveredColor: colors.lightBlue,\n    onChange: () => {}\n  }\n\n  static getDerivedStateFromProps(props: PropsType, state: StateType): Partial<StateType> | null {\n    // As long as the user isn't in the process of selecting, allow prop changes to re-populate selection state\n    if (state.selectionStart == null) {\n      return {\n        selectionDraft: [...props.selection],\n        dates: ScheduleSelector.computeDatesMatrix(props)\n      }\n    }\n    return null\n  }\n\n  static computeDatesMatrix(props: PropsType): Array<Array<Date>> {\n    const startTime = startOfDay(props.startDate)\n    const dates: Array<Array<Date>> = []\n    const minutesInChunk = Math.floor(60 / props.hourlyChunks)\n    for (let d = 0; d < props.numDays; d += 1) {\n      const currentDay = []\n      for (let h = props.minTime; h < props.maxTime; h += 1) {\n        for (let c = 0; c < props.hourlyChunks; c += 1) {\n          currentDay.push(addMinutes(addHours(addDays(startTime, d), h), c * minutesInChunk))\n        }\n      }\n      dates.push(currentDay)\n    }\n    return dates\n  }\n\n  constructor(props: PropsType) {\n    super(props)\n\n    this.state = {\n      selectionDraft: [...this.props.selection], // copy it over\n      selectionType: null,\n      selectionStart: null,\n      isTouchDragging: false,\n      dates: ScheduleSelector.computeDatesMatrix(props)\n    }\n\n    this.selectionSchemeHandlers = {\n      linear: selectionSchemes.linear,\n      square: selectionSchemes.square\n    }\n\n    this.endSelection = this.endSelection.bind(this)\n    this.handleMouseUpEvent = this.handleMouseUpEvent.bind(this)\n    this.handleMouseEnterEvent = this.handleMouseEnterEvent.bind(this)\n    this.handleTouchMoveEvent = this.handleTouchMoveEvent.bind(this)\n    this.handleTouchEndEvent = this.handleTouchEndEvent.bind(this)\n    this.handleSelectionStartEvent = this.handleSelectionStartEvent.bind(this)\n  }\n\n  componentDidMount() {\n    // We need to add the endSelection event listener to the document itself in order\n    // to catch the cases where the users ends their mouse-click somewhere besides\n    // the date cells (in which case none of the DateCell's onMouseUp handlers would fire)\n    //\n    // This isn't necessary for touch events since the `touchend` event fires on\n    // the element where the touch/drag started so it's always caught.\n    document.addEventListener('mouseup', this.endSelection)\n\n    // Prevent page scrolling when user is dragging on the date cells\n    this.cellToDate.forEach((value, dateCell) => {\n      if (dateCell && dateCell.addEventListener) {\n        // @ts-ignore\n        dateCell.addEventListener('touchmove', preventScroll, { passive: false })\n      }\n    })\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('mouseup', this.endSelection)\n    this.cellToDate.forEach((value, dateCell) => {\n      if (dateCell && dateCell.removeEventListener) {\n        // @ts-ignore\n        dateCell.removeEventListener('touchmove', preventScroll)\n      }\n    })\n  }\n\n  // Performs a lookup into this.cellToDate to retrieve the Date that corresponds to\n  // the cell where this touch event is right now. Note that this method will only work\n  // if the event is a `touchmove` event since it's the only one that has a `touches` list.\n  getTimeFromTouchEvent(event: React.TouchEvent<any>): Date | null {\n    const { touches } = event\n    if (!touches || touches.length === 0) return null\n    const { clientX, clientY } = touches[0]\n    const targetElement = document.elementFromPoint(clientX, clientY)\n    if (targetElement) {\n      const cellTime = this.cellToDate.get(targetElement)\n      return cellTime ?? null\n    }\n    return null\n  }\n\n  endSelection() {\n    this.props.onChange(this.state.selectionDraft)\n    this.setState({\n      selectionType: null,\n      selectionStart: null\n    })\n  }\n\n  // Given an ending Date, determines all the dates that should be selected in this draft\n  updateAvailabilityDraft(selectionEnd: Date | null, callback?: () => void) {\n    const { selectionType, selectionStart } = this.state\n\n    if (selectionType === null || selectionStart === null) return\n\n    let newSelection: Array<Date> = []\n    if (selectionStart && selectionEnd && selectionType) {\n      newSelection = this.selectionSchemeHandlers[this.props.selectionScheme](\n        selectionStart,\n        selectionEnd,\n        this.state.dates\n      )\n    }\n\n    let nextDraft = [...this.props.selection]\n    if (selectionType === 'add') {\n      nextDraft = Array.from(new Set([...nextDraft, ...newSelection]))\n    } else if (selectionType === 'remove') {\n      nextDraft = nextDraft.filter(a => !newSelection.find(b => isSameMinute(a, b)))\n    }\n\n    this.setState({ selectionDraft: nextDraft }, callback)\n  }\n\n  // Isomorphic (mouse and touch) handler since starting a selection works the same way for both classes of user input\n  handleSelectionStartEvent(startTime: Date) {\n    // Check if the startTime cell is selected/unselected to determine if this drag-select should\n    // add values or remove values\n    const timeSelected = this.props.selection.find(a => isSameMinute(a, startTime))\n    this.setState({\n      selectionType: timeSelected ? 'remove' : 'add',\n      selectionStart: startTime\n    })\n  }\n\n  handleMouseEnterEvent(time: Date) {\n    // Need to update selection draft on mouseup as well in order to catch the cases\n    // where the user just clicks on a single cell (because no mouseenter events fire\n    // in this scenario)\n    this.updateAvailabilityDraft(time)\n  }\n\n  handleMouseUpEvent(time: Date) {\n    this.updateAvailabilityDraft(time)\n    // Don't call this.endSelection() here because the document mouseup handler will do it\n  }\n\n  handleTouchMoveEvent(event: React.TouchEvent) {\n    this.setState({ isTouchDragging: true })\n    const cellTime = this.getTimeFromTouchEvent(event)\n    if (cellTime) {\n      this.updateAvailabilityDraft(cellTime)\n    }\n  }\n\n  handleTouchEndEvent() {\n    if (!this.state.isTouchDragging) {\n      // Going down this branch means the user tapped but didn't drag -- which\n      // means the availability draft hasn't yet been updated (since\n      // handleTouchMoveEvent was never called) so we need to do it now\n      this.updateAvailabilityDraft(null, () => {\n        this.endSelection()\n      })\n    } else {\n      this.endSelection()\n    }\n    this.setState({ isTouchDragging: false })\n  }\n\n  renderDateCellWrapper = (time: Date): JSX.Element => {\n    const startHandler = () => {\n      this.handleSelectionStartEvent(time)\n    }\n\n    const selected = Boolean(this.state.selectionDraft.find(a => isSameMinute(a, time)))\n\n    return (\n      <GridCell\n        className=\"rgdp__grid-cell\"\n        role=\"presentation\"\n        key={time.toISOString()}\n        // Mouse handlers\n        onMouseDown={startHandler}\n        onMouseEnter={() => {\n          this.handleMouseEnterEvent(time)\n        }}\n        onMouseUp={() => {\n          this.handleMouseUpEvent(time)\n        }}\n        // Touch handlers\n        // Since touch events fire on the event where the touch-drag started, there's no point in passing\n        // in the time parameter, instead these handlers will do their job using the default Event\n        // parameters\n        onTouchStart={startHandler}\n        onTouchMove={this.handleTouchMoveEvent}\n        onTouchEnd={this.handleTouchEndEvent}\n      >\n        {this.renderDateCell(time, selected)}\n      </GridCell>\n    )\n  }\n\n  renderDateCell = (time: Date, selected: boolean): JSX.Element => {\n    const refSetter = (dateCell: HTMLElement | null) => {\n      if (dateCell) {\n        this.cellToDate.set(dateCell, time)\n      }\n    }\n    if (this.props.renderDateCell) {\n      return this.props.renderDateCell(time, selected, refSetter)\n    } else {\n      return (\n        <DateCell\n          selected={selected}\n          ref={refSetter}\n          selectedColor={this.props.selectedColor}\n          unselectedColor={this.props.unselectedColor}\n          hoveredColor={this.props.hoveredColor}\n        />\n      )\n    }\n  }\n\n  renderTimeLabel = (time: Date): JSX.Element => {\n    if (this.props.renderTimeLabel) {\n      return this.props.renderTimeLabel(time)\n    } else {\n      return <TimeText>{formatDate(time, this.props.timeFormat)}</TimeText>\n    }\n  }\n\n  renderDateLabel = (date: Date): JSX.Element => {\n    if (this.props.renderDateLabel) {\n      return this.props.renderDateLabel(date)\n    } else {\n      return <DateLabel>{formatDate(date, this.props.dateFormat)}</DateLabel>\n    }\n  }\n\n  renderFullDateGrid(): Array<JSX.Element> {\n    const flattenedDates: Date[] = []\n    const numDays = this.state.dates.length\n    const numTimes = this.state.dates[0].length\n    for (let j = 0; j < numTimes; j += 1) {\n      for (let i = 0; i < numDays; i += 1) {\n        flattenedDates.push(this.state.dates[i][j])\n      }\n    }\n    const dateGridElements = flattenedDates.map(this.renderDateCellWrapper)\n    for (let i = 0; i < numTimes; i += 1) {\n      const index = i * numDays\n      const time = this.state.dates[0][i]\n      // Inject the time label at the start of every row\n      dateGridElements.splice(index + i, 0, this.renderTimeLabel(time))\n    }\n    return [\n      // Empty top left corner\n      <div key=\"topleft\" />,\n      // Top row of dates\n      ...this.state.dates.map((dayOfTimes, index) =>\n        React.cloneElement(this.renderDateLabel(dayOfTimes[0]), { key: `date-${index}` })\n      ),\n      // Every row after that\n      ...dateGridElements.map((element, index) => React.cloneElement(element, { key: `time-${index}` }))\n    ]\n  }\n\n  render(): JSX.Element {\n    return (\n      <Wrapper>\n        <Grid\n          columns={this.state.dates.length}\n          rows={this.state.dates[0].length}\n          columnGap={this.props.columnGap}\n          rowGap={this.props.rowGap}\n          ref={el => {\n            this.gridRef = el\n          }}\n        >\n          {this.renderFullDateGrid()}\n        </Grid>\n      </Wrapper>\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}